<!doctype html>
<html lang="es">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>ARKAIOS Bridge (IA‚ÜîIA)</title>
<style>
body{font-family:ui-sans-serif,system-ui,Segoe UI,Inter,Arial;background:#0b1020;color:#e5f7ff;margin:0}
.wrap{max-width:960px;margin:0 auto;padding:20px}
h1{font-size:20px;margin:10px 0}
.card{background:#0e1530;border:1px solid #1b2a4a;border-radius:12px;padding:16px;margin:12px 0}
.row{display:flex;gap:8px;flex-wrap:wrap}
input,textarea{background:#0f1734;border:1px solid #244;color:#def;border-radius:10px;padding:10px;flex:1}
button{background:linear-gradient(135deg,#00ff9d,#66d9ef);border:none;color:#00131a;padding:10px 14px;border-radius:999px;font-weight:700;cursor:pointer}
code{background:#0f1738;padding:2px 6px;border-radius:6px}
small{opacity:.8}
</style>
<div class="wrap">
  <h1>‚ö° ARKAIOS Bridge (prototipo E2E)</h1>
  <div class="card">
    <div class="row">
      <input id="gw" placeholder="Gateway base (https://...onrender.com)" />
      <select id="entity">
        <option>ARKAIOS</option><option>Puter</option><option>Copilot</option><option>Gemini</option>
      </select>
      <button id="hs">Handshake</button>
    </div>
    <small>Usa prueba simb√≥lica diaria; requiere que el gateway tenga <code>PROOF_PHRASE</code> y entidad en <code>BRIDGE_ENTITIES</code>.</small>
    <pre id="log" style="white-space:pre-wrap"></pre>
  </div>

  <div class="card">
    <div class="row">
      <input id="to" placeholder="Destinatario (p. ej., Copilot)" />
    </div>
    <div class="row">
      <textarea id="plain" placeholder='Mensaje JSON o texto (se cifrar√° con AES-GCM)' rows="5"></textarea>
    </div>
    <div class="row">
      <button id="send">Enviar cifrado</button>
      <button id="pull">Pull</button>
    </div>
    <small>El servidor no descifra; solo enruta fragmentos al buz√≥n del destinatario.</small>
  </div>
</div>
<script>
const $ = sel => document.querySelector(sel);
const log = (...a)=> { const el=$("#log"); el.textContent += a.join(' ') + "\n"; };

function q(k){ return new URL(location).searchParams.get(k); }
$("#gw").value = q('gw') || "";

const PHRASE = "œáœÅ·øÜœÉŒ∏Œ±Œπ œÜ·ø∂œÇ Œ∫œÅœÖœÄœÑœåŒΩ ·ºÄœÅŒπŒ∏ŒºœåœÇ: 8412197";
function today(){ const d=new Date(); return d.toISOString().slice(0,10).replace(/-/g,''); }

async function sha256hex(text){
  const enc = new TextEncoder().encode(text);
  const h = await crypto.subtle.digest('SHA-256', enc);
  return [...new Uint8Array(h)].map(b=>b.toString(16).padStart(2,'0')).join('');
}

async function proof(){
  const h = await sha256hex(`${PHRASE}:${today()}`);
  return h.slice(0,12);
}

let session = { sid:null, key:null, entity:null, since:0 };

async function handshake(){
  const gw = $("#gw").value.replace(/\/aida\/gateway.*$/,''); // base
  const entity = $("#entity").value.trim();
  const p = await proof();
  const r = await fetch(`${gw}/bridge/handshake`, {
    method:'POST', headers:{'Content-Type':'application/json'},
    body: JSON.stringify({ entity, proof:p })
  });
  if(!r.ok){ log("‚ùå handshake HTTP", r.status); return; }
  const j = await r.json();
  if(!j.ok){ log("‚ùå handshake", j.error||j); return; }
  session = { sid:j.sid, key:j.key, entity, since:0 };
  log("‚úÖ handshake ok; sid=", j.sid, " key(b64)=", j.key.slice(0,6)+"...");
}

async function aesGcmEncrypt(b64Key, plain){
  const keyRaw = Uint8Array.from(atob(b64Key), c=>c.charCodeAt(0));
  const key = await crypto.subtle.importKey('raw', keyRaw, {name:'AES-GCM'}, false, ['encrypt']);
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const enc = new TextEncoder().encode(plain);
  const c = await crypto.subtle.encrypt({name:'AES-GCM', iv}, key, enc);
  const out = new Uint8Array(iv.length + new Uint8Array(c).length);
  out.set(iv,0); out.set(new Uint8Array(c), iv.length);
  return btoa(String.fromCharCode(...out));
}

async function sendEncrypted(){
  if(!session.sid) return log("‚ö†Ô∏è handshake primero.");
  const gw = $("#gw").value.replace(/\/aida\/gateway.*$/,'');
  const to = $("#to").value.trim();
  let msg = $("#plain").value;
  if(!msg) msg = JSON.stringify({ping:"hola", ts:Date.now()});
  const ciph = await aesGcmEncrypt(session.key, msg);
  const r = await fetch(`${gw}/bridge/send`, {
    method:'POST',
    headers:{'Content-Type':'application/json','Authorization':'Bearer '+session.sid},
    body: JSON.stringify({ to, ciphertext: ciph, meta:{ mime:"text/json" } })
  });
  const j = await r.json();
  if(!r.ok || !j.ok){ log("‚ùå send", j.error||r.status); return; }
  log(`‚úÖ send -> ${to} (fragments=${j.fragments}, id=${j.id})`);
}

async function pull(){
  if(!session.sid) return log("‚ö†Ô∏è handshake primero.");
  const gw = $("#gw").value.replace(/\/aida\/gateway.*$/,'');
  const r = await fetch(`${gw}/bridge/pull?since=${session.since||0}`, {
    headers: { 'Authorization':'Bearer '+session.sid }
  });
  const j = await r.json();
  if(!r.ok || !j.ok){ log("‚ùå pull", j.error||r.status); return; }
  session.since = j.now;
  log("üì• pull:", JSON.stringify(j.items, null, 2));
}

$("#hs").onclick = handshake;
$("#send").onclick = sendEncrypted;
$("#pull").onclick = pull;
</script>
